/*******************************************************************************************
  SIMPL+ Module Information
  (Fill in comments below)
*******************************************************************************************/
/*
Dealer Name:
System Name: baby timer for sleep/wake/TOD
System Number:
Programmer: GW
Comments:

 + TODO: if duration is negative (start time is in future), then duration should show
   negative, not 23:55 (wrapped) or whatever.
   Actually this problem is worse than that...more complicated; needs fixing.  FIXME

*/

/*******************************************************************************************
  Compiler Directives
  (Uncomment and declare compiler directives as needed)
*******************************************************************************************/
// #ENABLE_DYNAMIC
// #SYMBOL_NAME ""
// #HINT ""
// #DEFINE_CONSTANT
// #CATEGORY "" 
// #PRINT_TO_TRACE
// #DIGITAL_EXPAND 
// #ANALOG_SERIAL_EXPAND 
// #OUTPUT_SHIFT 
// #HELP_PDF_FILE ""
#DEFAULT_VOLATILE
#ENABLE_STACK_CHECKING

#ENABLE_TRACE

// #ENCODING_ASCII
// #ENCODING_UTF16
// #ENCODING_INHERIT_FROM_PARENT
// #ENCODING_INHERIT_FROM_PROGRAM
/*
#HELP_BEGIN
   (add additional lines of help lines)
#HELP_END
*/

#DEFINE_CONSTANT UPDATE_INTERVAL 200	//200=2seconds refresh for h/m counter
#DEFINE_CONSTANT MAX_HISTORY 10
#DEFINE_CONSTANT MAXLEN_HISTORY_ITEM 25  // MAX_HISTORY * (MAXLEN_HISTORY_ITEM+1 for CR) must be less than the output string (system limited 255)
					// 0        1         2
					// 1234567890123456789012345 <-- MAXLEN_HISTORY_ITEM
					// SLEEP: 18:03 (12.5...     examples
					// SLEEP: 18:03 (12.5)

DIGITAL_INPUT
	sleep_pr,
	wake_pr,
	off_pr,
	time_inc_pr,
	time_dec_pr
	;

ANALOG_INPUT
	arg1,
	arg2
	;

STRING_OUTPUT
	tod$,
	since_title$,
	since_time$,
	duration_title$,
	duration_h$,
	duration_unit$,
	date$,
	history$
	;
ANALOG_OUTPUT
	select_item#,
	deselect_item#
	;

STRUCTURE time_entry {
	integer h, m, s;
	string dur[5];  //examples: "-12.0"  "-12", "4", "4.0", "4.1"  (text signed numbers with optional one-place decimal)
	string type[5];  // "SLEEP" | "WAKE" | "OFF" | ""
};

NONVOLATILE INTEGER
	i_start_h, i_start_m, i_start_s, save_select, i_curr;
NONVOLATILE STRING
	s_history[MAX_HISTORY][MAXLEN_HISTORY_ITEM],
	Curr_Dur[5];   // e.g. "-12.1" or "12.0"
NONVOLATILE time_entry
	TE[MAX_HISTORY];
//SIGNED_INTEGER Dur_h;  //DEPRECATING...
//INTEGER Dur_dec;  //DEPRECATING...

//
// Outputs history string.
//
FUNCTION remake_history_string() {
	integer i;
	string s[255];
	s = "";
	append_flag = 0;

	for ( i = 1 to i_curr ) {
		
		/* Current entry: append duration dynamically */
		/* (also guard against reading past array max) */
		if ( i = i_curr || i=MAX_HISTORY ) {
			/* Current (latest) history item: append duration dynamically */
			MakeString ( s, "%s%s: %u:%u %s (%d.%u...\r", s, TE[i].type, TE[i].h, TE[i].m, Dur_h, Dur_dec );
		} else {
			/* Regular (non-current) item: use structure value */
			MakeString ( s, "%s%s: %u:%u %s (%s)\r", s, TE[i].type, TE[i].h, TE[i].m, TE[i].dur );
		}
	}

	/* Chop trailing newline, if any */
	if ( Len(s) > 0 ) {
		s = Left ( s, Len(s)-1 );
	}

	/* Output string */
	history$ = s;

}

//
// Appends duration tag string to specified history item
// and updates history string.
// 
FUNCTION append_duration ( integer pos ) {
//DEPRECATED???
	/* Item doesn't exist? */
	if ( pos < 1 || pos > MAX_HISTORY ) return;

	/* Append to item */
	if ( Dur_dec = 0 ) {
		/* No decimal place */
		MakeString ( s_history[pos], "%s (%d)", s_history[pos], Dur_h );

	} else {
		/* Decimal place */
		MakeString ( s_history[pos], "%s (%d.%u)", s_history[pos], Dur_h, Dur_dec );
	}
	remake_history_string();
}

//
// Modifies 2nd-to-last history string to change its duration tag,
// if it exists, to the specified new duration string.
// and updates the output history string.
//
FUNCTION change_2ndlast_history_duration ( signed_integer inc ) {
	integer i, pos, pos2, pos3;
	signed_integer olddurd;  //olddurd e.g. -121 for -12.1 (multiplied by 10)

	/* No 2nd-to-last entry (fewer than 2)? */
	if ( s_history[2] = "" ) return;

	/* Find 2nd-to-last pos */
	/* List is full? */
	if ( s_history[MAX_HISTORY] <> "" ) {
		/* Full list: use max - 1 */
		pos = MAX_HISTORY - 1;
	} else {
		/* Partial list: find last entry */
		/* (already know list has at least 2 entries, so start at 3) */
		for ( i = 3 to MAX_HISTORY ) {
			if ( s_history[i] = "" ) {
				/* End of list */
				pos = i - 2;
				break;
			}
		}
	}

	/* Recalc prior dur */
	


	/* Rewrite pos item starting at the parenthesis */
	/* Example:  SLEEP: 15:00 (1.6) */
	pos2 = Find ( "(", s_history[pos] );  //parens
	if ( pos2 = 0 ) {
		/* Error: duration not found on item */
		print ( "Error: baby timer.usp: change_2ndlast_history_duration(): duration not found on 2nd to last item.\n" );
		return;
	}
	pos3 = Find ( ".", s_history[pos], pos2 ); //decimal point

	/* Get old dur (times ten; one decimal place, shifted to integer) */
	if ( pos3 = 0 ) {
		/* No decimal found; add a zero */
		olddur = AToI ( Left(s_history[pos],pos2) );
	} else {
		//olddur = AToI ( Left(s_history[pos],pos2) + Left(s_history[pos],pos3) );
	}

	/* Chop from right after the parens start, and append from there */
	//MakeString ( s_history[pos], "%s%d)", Left ( s_history[pos], pos2 ), olddur+inc
	
	remake_history_string();
}

//
// Adds specified history item string to history array
// and updates the output string.
//
//FUNCTION add_history ( string s ) {
FUNCTION add_start_history ( string newType ) {
	integer i;

	/* Shift list if full */
	if ( i_curr = MAX_HISTORY ) {
		for ( i = 2 to MAX_HISTORY ) {
			TE[i-1] = TE[i];
		}
		TE[MAX_HISTORY] = "";
		//i_curr remains at MAX_HISTORY
	}

	/* Add new entry */
	s_history[i_curr] = s;
	TE[i_curr].h = i_start_h;
	TE[i_curr].m = i_start_m;
	TE[i_curr].s = i_start_s;
	TE[i_curr].type = newType;
	TE[i_curr].dur = "";  //current dur will be updated dynamically during update_times()

	/* Update output string */
	remake_history_string();
}

FUNCTION set_start_now() {
	i_start_h = GetHourNum();
	i_start_m = GetMinutesNum();
	i_start_s = GetSecondsNum();
	MakeString ( since_time$, "%u:%02u", i_start_h, i_start_m);
	duration_title$ = "DURATION";
	duration_h$ = "0";
	duration_unit$ = "hr";
}

//
// Calculates duration between specified two time entries.
// Returns string duration (5 chars max, could be negative).
//
STRING_FUNCTION calc_duration ( time_entry te1, time_entry te2 ) {
	integer h, m, s, dur_dec;
	signed_integer dur_h;
	string ret[5];

	h = GetHourNum();
	m = GetMinutesNum();
	s = GetSecondsNum();
	Trace ( "calc_duration()...\n" );

	/* Wrap properly */
	if ( te2.s < te1.s ) {
		te2.s = te2.s + 60;
		te2.m = te2.m - 1;
	}
	if ( te2.m < te1.m ) {
		te2.m = te2.m + 60;
		te2.h = te2.h - 1;
	}
	if ( te2.h < te1.h ) {
		te2.h = te2.h + 24;
	}
	if ( te2.m < te1.m ) {
		/* m is before start m; check 12 hours either way */
		if ( te1.m - te2.m < 12 ) {
			/* Within 12 hours earlier: time duration from m till te1 */
			dur_h = 0; //FIXME
			dur_dec = 0; //FIXME
			Trace ( ">>>dur_h within 12 hours earlier... FIXME\n" );


		} else {
			/* Within 12 hours later, must be after midnight: add 24 to h */
			//FIXME te2.h = te2.h + 24;
			Trace ( ">>>dur_h else within 12 hours later, must be after midnight; add 24 to te2.h... FIXME\n" );
		}
	}

	/* Get decimal */
	dur_h = te2.h - te1.h;
	dur_dec = (te2.m-te1.m) / 6; //60 shifted 1 decimal place
	Trace ( "\tte2.m=%u:%d, te1.m=%u:%d  dur_h=%u:%d  dur_dec=%u\n", te2.m,te2.m, te1.m,te1.m, dur_h,dur_h, dur_dec );

	MakeString ( ret, "%d%u", dur_h, dur_d );

}

//
// Regular periodic call to update TOD clocks and duration fields outputs,
// as well as Duration globals (Dur_h, Dur_dec).
//
FUNCTION update_times() {	
	time_entry now;
	now.h = GetHourNum();
	now.m = GetMinutesNum();
	now.s = GetSecondsNum();
	Trace ( "update_times()...\n" );

	/* Time of Day and Date */
	MakeString ( tod$, "%u:%02u", now.h, now.m );
	MakeString ( date$, "%s %s %u, %u", Left(Day(), 3), Left(Month(), 3), GetDateNum(), GetYearNum() );


	/* Calc duration between current entry start time and now */
	Curr_Dur = calc_duration ( TE[i_curr], now );

	/* Output Duration only if in Sleep or Wake (not Off) */
	if ( select_item# = 1 || select_item# = 2 ) {
		//MakeString ( duration_h$, "%d.%u", Dur_h, Dur_dec );
		duration_h$ = Curr_dur;
		duration_unit$ = "hr";
	}

	/* Update current history duration, in any mode */
	remake_history_string();
}

FUNCTION select_item ( integer sel ) {
	if ( sel != 1 ) deselect_item# = 1;
	if ( sel != 2 ) deselect_item# = 2;
	if ( sel != 3 ) deselect_item# = 3;
	select_item# = sel;
	save_select = sel;
}

//
// Adjusts current sleep/wake start time by specified # of minutes (positive or negative).
// Affects i_start_XXX, output fields, and history array.
//
FUNCTION inc_time ( signed_integer inc ) {
	signed_integer m;
	m = i_start_m + inc;
	Trace ( "inc_time(%d) m=%d i_start_h=%u, i_start_m=%u,  m S/ 60=%u  m%60=%u m%60=%d\n", inc, m, i_start_h, i_start_m, m S/ 60, m%60, m%60 );

	/* Under/overflow m */
	i_start_h = i_start_h + ( m S/ 60 );  //signed division
	i_start_h = i_start_h % 24;
	while ( m < 0 ) {   //apparently MOD (%) does not work correctly for negative numbers, so mod negative numbers manually
		Trace ( "\t\tm=m+60 (m=%u:%d)\n", m,m );
		m = m + 60;  //shift 60 minutes forward
		i_start_h = i_start_h - 1;
		if ( i_start_h < 0 ) i_start_h = 23; //wrap to 23 (assuming i_start_h was positive to begin with)
		Trace ( "\t\t\ti_start_h <- %u:%d\n", i_start_h, i_start_h );
	}
	m = m % 60; //mod positive numbers
	Trace ( "\t\tm % 60 = (%u:%d)\n", m,m );
	i_start_m = m;
	Trace ( "\tnewh=%u newm=%u, m=%u m=%d\n", i_start_h, i_start_m, m,m );
	m = m % 60;
	Trace ( "\tm=%u m=%d\n", m,m );

	/* Update affected fields */
	MakeString ( since_time$, "%u:%02u", i_start_h, i_start_m);
	update_times();  //updates Dur_h and Dur_dec

	/* Fix 2nd to last history duration tag */
	change_2ndlast_history_duration ( inc );

}

PUSH sleep_pr {
	//string s[13];
	select_item ( 1 );
	since_title$ = "SLEEPING SINCE";
	set_start_now();
	//MakeString ( s, "SLEEP: %u:%02u", i_start_h, i_start_m );
	//add_history ( s );
	add_start_history ( "SLEEP" );
}
PUSH wake_pr {
	//string s[12];
	select_item ( 2 );
	since_title$ = "AWAKE SINCE";
	set_start_now();
	//MakeString ( s, "WAKE: %u:%02u", i_start_h, i_start_m );
	//add_history ( s );
	add_start_history ( "SLEEP" );
}
PUSH off_pr {
	//string s[10];
	select_item ( 3 );
	since_title$ = "";
	since_time$ = "";
	duration_title$ = "";
	duration_h$ = "";
	duration_unit$ = "";
	//MakeString ( s, "OFF: %u:%02u", GetHourNum(), GetMinutesNum() );
	//add_history ( s );
	add_start_history ( "OFF" );
	Delay ( 100 );
	deselect_item# = 3;  //darken hiliting when off
}
PUSH time_inc_pr {
	inc_time ( 10 );

}
PUSH time_dec_pr {
	inc_time ( -10 );

}
function Main() {

	/* Init globals */
	Dur_h = 0;
	Dur_dec = 0;

	/* Recall status */
	WaitForInitializationComplete();
	if ( save_select > 0 ) {
		select_item ( save_select ); //recall selection from NVRAM
		cswitch ( save_select ) {
			case (1): {
				since_title$ = "*SLEEPING SINCE";
				MakeString ( since_time$, "%u:%02u", i_start_h, i_start_m);
				duration_title$ = "*DURATION";
				break;
			}
			case (2): {
				since_title$ = "*AWAKE SINCE";
				MakeString ( since_time$, "%u:%02u", i_start_h, i_start_m);
				duration_title$ = "*DURATION";
				break;
			}
		}
	}
	
	/* Run main update loop */
	while ( 1 ) {
		update_times();
		Delay ( UPDATE_INTERVAL );
	}
}
CHANGE arg1
CHANGE arg2 {
	signed_integer r1;
	integer r2;
	r1 = arg1 MOD arg2;
	r2 = arg1 MOD arg2;
	Trace ( "(%u:%d) % (%u:%d) = (%u:%d)(%u:%d)\n", arg1,arg1, arg2,arg2, r1,r1, r2,r2 );
}
